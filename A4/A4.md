# IFC Thermal Quantifier

A Python tool that automates the extraction of building envelope data from IFC (Industry Foundation Classes) models. It parses Windows, Walls, Slabs, and Roofs to generate a comprehensive **Thermal Report** in Excel format, calculating weighted average U-values and material quantities.

## Features

*   **Automated Extraction:** Scans IFC models for Walls, Windows, Slabs, and Roofs.
*   **Smart Data Cleaning:** Converts messy text inputs (e.g., "150mm", "0.3 W/mÂ²K") into usable float numbers.
*   **Window Logic:** Calculates composite U-values by separating Frame and Glass areas.
*   **Geometric Fallback:** If property set areas are missing, it calculates area physically using 3D geometry (`ifcopenshell.geom`).
*   **User assistance:** Extracts X/Y/Z coordinates and internal/external properties for every element to assist in locating "bad" data.
*   **Excel Export:** Generates a multi-sheet Excel report on your Desktop containing both summaries and raw data.
---

## Prerequisites & Installation

This tool is designed to run locally on your computer. It is optimized for the **Spyder IDE** (typically installed with Anaconda).

### 1. Install Dependencies
This tool relies on `ifcopenshell` for BIM processing and `pandas` for data handling, only `ifcopenshell` needs an installation. Paste the following into the terminal and press enter:

```bash
pip install ifcopenshell
```

*> **Note:** If `pip install ifcopenshell` fails (as it depends on C++ libraries), it is recommended to install via Conda: `conda install -c conda-forge ifcopenshell`*

### 2. Folder Setup
The script is programmed to look for the IFC file in the **exact same folder** as the Python file.

1.  Create a new folder on your computer (e.g., `Documents/Thermal_Tool`).
2.  Save the code as `main.py` inside that folder.
3.  **Copy your `.ifc` file into that exact same folder.**

**Your folder structure must look like this:**
```text
ðŸ“‚ Thermal_Tool
 â”œâ”€â”€ ðŸ“„ main.py
 â””â”€â”€ ðŸ“„ 25-16-D-ARCH.ifc
```

### 3. Running the Code
1.  Open `main.py` in **Spyder**.
2.  Make sure the filename in the configuration section matches your specific IFC file.
3.  Press the **Run** button (Green Play icon or F5).

---

## Configuration

Before running the script, you must specify your target IFC file inside the code.

1.  Open the python script.
2.  Locate the **Configuration** section near the top:

```python
# --- CONFIGURATION ---
IFC_FILENAME = "25-16-D-ARCH.ifc"  # <--- CHANGE THIS to your filename
```

3.  (Optional) You can also adjust the default values used for windows if specific manufacturer data is missing in the model:

```python
# Window Defaults
DEFAULTS = {
    "FRAME_K": 0.17,       # Frame thermal conductivity (W/mK)
    "FRAME_THICK": 0.07,   # Frame thickness (m)
    "GLASS_U": 1.2         # Glass center-of-glazing U-value
}
```

---

## Technical Walkthrough

This code operates as a linear pipeline that transforms raw, unstructured BIM data into a structured engineering report. Below is the detailed logic flow.

### 1. The "Fuzzy" Property Hunter
One of the biggest challenges with IFC files is that parameters are inconsistent. A U-Value might be called "ThermalTransmittance", "U-Value", or "Heat Transfer Coeff".

To solve this, the code uses a **Fuzzy Search Strategy** implemented in `find_prop_value`.

*   **Logic:** It iterates through every property set attached to an element.
*   **Merging:** It combines *Type Properties* (shared by the family) and *Instance Properties* (specific to the object) into a single dictionary. Instance properties always take precedence.
*   **Search:** It looks for partial string matches (e.g., matching "Width" inside "Frame Width").

```python
def find_prop_value(merged_props, keys_to_find, precise_pset=None):
    # Iterates through all property sets to find a key match
    for pset_name, props in merged_props.items():
        # Check against list of possible names (e.g. ["U Value", "ThermalTransmittance"])
        for k, v in props.items():
            for key in keys_to_find:
                if key.lower() in k.lower(): 
                    return get_real_value(v) # Returns the underlying value
    return None
```

### 2. Unit Normalization (`clean_numeric`)
BIM data often mixes strings and floats. The code includes a robust sanitizer to ensure all dimensions are converted to **Meters**.

*   **Regex Parsing:** Handles strings like `"150mm"` or `"0.15m"`.
*   **Heuristic:** If a raw number is greater than `20` (e.g., `300`), the code assumes the input is in millimeters and divides by 1000.

```python
def clean_numeric(val):
    s = str(val).strip().lower()
    # 1. Regex for explicit units
    if "mm" in s:
        num = re.search(r"(\d+(\.\d+)?)", s)
        return float(num.group(1)) / 1000.0
    
    # 2. Heuristic for raw numbers (Assuming wall thickness > 20m is impossible)
    f = float(val)
    if f > 20: return f / 1000.0
    return f
```

### 3. Spatial Location Mapping (`get_geo_loc`)
To assist users in locating elements with missing data, the script extracts the precise 3D coordinates.

*   **Matrix Math:** It retrieves the `ObjectPlacement` and parses the 4x4 Transformation Matrix.
*   **Translation:** It extracts the translation vector (column 3) to get the X, Y, Z origin.

```python
def get_geo_loc(element):
    matrix = ifcopenshell.util.placement.get_local_placement(element.ObjectPlacement)
    x, y, z = matrix[0][3], matrix[1][3], matrix[2][3]
    return f"{round(x,3)}_{round(y,3)}_{round(z,3)}"
```

### 4. Window Physics Engine (`process_windows`)
Windows are calculated as composite elements. The code attempts to derive a **Weighted U-Value** based on the specific ratio of Frame to Glass.

1.  **Material Scan:** The code traverses the `IfcRelAssociatesMaterial` relationship. It searches for keywords like `"glass"` or `"glaz"` inside `IfcMaterialConstituentSet` or `IfcMaterialList` to separate the glazing material from the frame.
2.  **Geometry Calculation:**
    *   If `FrameWidth` is found: It calculates the exact geometric area of the frame vs the glass.
    *   *Fallback:* If dimensions are missing, it applies a default standard: **15% Frame / 85% Glass**.
3.  **Physics Formula:**

$$ U_{total} = \frac{(U_{glass} \cdot A_{glass}) + (U_{frame} \cdot A_{frame})}{A_{total}} $$

```python
# Logic excerpt from process_windows
if frame_w and w_m and h_m:
    # Precise Area Calculation
    inner_w = max(0.0, w_m - 2*frame_w)
    inner_h = max(0.0, h_m - 2*frame_w)
    g_area = inner_w * inner_h
    f_area = max(0.0, area_total - g_area)
else:
    # Fallback Ratio
    f_area = area_total * 0.15
    g_area = area_total * 0.85
```

### 5. Geometry Fallback Engine (`process_slabs`)
For complex geometry (like Roofs or Slabs) where the architect may not have exported a "NetArea" property, the code utilizes the `ifcopenshell.geom` engine.

*   **Mesh Generation:** It converts the IFC implicit geometry into a triangular mesh.
*   **Normal Vector Analysis:** To get the "Footprint" or "Top Surface Area", the code iterates through every face of the mesh. It calculates the **Cross Product** to find the normal vector.
*   **Selection:** It only sums the area of faces pointing **Upwards** (Positive Z-axis).

```python
def calculate_geom_area(elem):
    shape = ifcopenshell.geom.create_shape(settings, elem)
    # ... extract verts and faces ...
    for face in faces:
        p1, p2, p3 = verts[face[0]], verts[face[1]], verts[face[2]]
        cross = np.cross(p2 - p1, p3 - p1)
        
        # Check if Normal Vector points UP (Z > 0)
        if (cross / np.linalg.norm(cross))[2] > 0:
            total_up += 0.5 * np.linalg.norm(cross) # Add Triangle Area
    return total_up
```

### 6. Weighted Aggregation (`run_main`)
In the final step, the code uses `pandas` to generate the Excel report. It groups elements by Type and Category.

Crucially, it calculates **Area-Weighted Averages** for U-Values. A simple arithmetic mean would be inaccurate because small elements would skew the data as much as large ones.

```python
def weighted_avg(x):
    # Numpy weighted average using Area as the weight
    return np.average(valid_rows['U_Value'], weights=valid_rows['Area_m2'])
```

---

## Design Decisions & Exclusions

### Why are Doors excluded?
You will notice the script processes `IfcWindow`, `IfcWall`, `IfcSlab`, and `IfcRoof`, but explicitly ignores `IfcDoor`. This is due to two critical issues:

1.  **Data Reliability (Internal vs. External):** In many BIM workflows, the `IsExternal` property for doors is set manually and often defaults to "True". Consequently, internal doors (e.g., apartment entrances, corridor doors) are frequently mislabeled as external. Including them would erroneously inflate the building envelope area, destroying the accuracy of the thermal report.
2.  **Material Complexity:** Doors are complex hybrid elements. A single door entity often contains an opaque panel (wood/steel), a glazing panel, and a frame. Applying the standard "Window Logic" (simple Frame/Glass ratio) would result in scientifically inaccurate U-values.

### Why Weighted Averages?
The **Master Summary** uses **Area-Weighted Averages** for U-Values, not simple arithmetic means.

$$ U_{avg} = \frac{\sum (U_i \times Area_i)}{\sum Area_{total}} $$

**Reasoning:** A small bathroom window ($0.5m^2$) should not have the same impact on the building's overall thermal performance as a large curtain wall element ($10m^2$). Simple averaging would skew the results significantly.

---

## The Output Report

The script automatically generates an Excel file named `{Filename}_THERMAL_REPORT.xlsx`. The report is structured into three tiers of granularity:

| Sheet Name | Description | Key Columns |
| :--- | :--- | :--- |
| **MASTER SUMMARY** | The "Executive Summary." Aggregates the entire building by Category and Position. | `Category`, `Position`, `Total_Area`, `Weighted_Avg_U` |
| **[Type] Summary** | Grouped statistics. Useful for checking if a specific wall type (e.g., "Ext_Wall_Brick") is performing as expected. | `Type_Name`, `Thickness_mm`, `Avg_U` |
| **[Type] Data** | **Raw Data.** Every single element found in the model is listed here. Use this to find specific "bad" elements. | `GlobalId`, `GeoLocation` (X_Y_Z), `FrameMat`, `GlassMat` |

---

## Known Limitations

1.  **Curved Geometry:** The geometric area calculator (`ifcopenshell.geom`) approximates curved surfaces (like domes or curved walls) by triangulating them. For extremely high-curvature surfaces, the area may vary slightly from the exact mathematical surface area.
2.  **Missing Property Sets:** If an IFC file contains no thermal properties (`ThermalTransmittance`) and no material associations, the `U_Value` column will result in `None`. The script cannot "guess" physics without input data.
3.  **Excel Permissions:** The script saves to the Desktop. If the file is already open in Excel, the script will fail with a `PermissionError`. **Close the Excel file before re-running the script.**

---

## Youtube link to toturial

[![YouTube Video Thumbnail](https://img.youtube.com/vi/wB1RuHo_UFM/maxresdefault.jpg)](https://www.youtube.com/watch?v=wB1RuHo_UFM)

---

## Summary
Title: IFC Thermal Quantifier: Automated Envelope Analysis and Reporting  
Category: Level 1 Modeller  
Description: A Python tool that parses IFC models to quantify building envelope thermal performance. It calculates composite U-values, handles geometric area extraction, and generates detailed Excel reports for thermal analysis.  
